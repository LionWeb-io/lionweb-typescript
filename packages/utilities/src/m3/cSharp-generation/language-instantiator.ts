import {
    Annotation,
    Classifier,
    Concept,
    Enumeration,
    Feature,
    IKeyed,
    Interface,
    Language,
    LanguageEntity,
    Link,
    lioncoreBuiltins,
    nameSorted,
    PrimitiveType,
    Property,
    SingleRef,
    unresolved
} from "@lionweb/core"
import {asString, indentWith} from "littoral-templates"
import {cond} from "../ts-generation/text-generation-utils.js"


const indent = indentWith("    ")


const propertiesAsStrings = <T>(t: T, ...propertyNames: (keyof T)[]) =>
    propertyNames.map((propertyName) => `"${t[propertyName]}"`).join(", ")


const constructorCall = (thing: IKeyed) =>
    `${thing.constructor.name}(${propertiesAsStrings(thing, "id", "key", "name")})`;


const typeRefFor = (ref: SingleRef<LanguageEntity>) =>
    ref === unresolved
        ? `???`
        : (
            ref.language === lioncoreBuiltins
                ? `BuiltIns.`
                : ``
        ) + ref.name


const modifiersFor = (feature: Feature): string => {
    const optionalSetting = feature.optional ? `.IsOptional()` : ``
    if (feature instanceof Link) {
        return `.OfType(${typeRefFor(feature.type)})${feature.multiple ? `.IsMultiple()` : ``}${optionalSetting}`
    }
    if (feature instanceof Property) {
        return `.OfType(${typeRefFor(feature.type)})${optionalSetting}`
    }
    throw new Error(`instance of ${feature.constructor.name} not handled by #modifiersFor`)
}


const postInstantiateForClassifier = (classifier: Classifier, settingsExpr: string) => {
    const featureInstantiations = classifier.features.map((feature) => [
        `${classifier.name}.${feature.constructor.name}(${propertiesAsStrings(feature, "id", "key", "name")})${modifiersFor(feature)};`
    ])
    return !!settingsExpr || featureInstantiations.length > 0
        ? [
            ``,
            cond(!!settingsExpr, `${classifier.name}${settingsExpr};`),
            ...featureInstantiations
        ]
        : []
}

const extendingSettingsFor = (extensible: (Annotation | Concept)) =>
    [
        ...(extensible.extends
            ? [`.Extending(${extensible.extends.name})`]
            : []
        ),
        cond(extensible.implements.length > 0, `.Implementing(${extensible.implements.map(typeRefFor).join(", ")})`)
    ]

const postInstantiate = (entity: LanguageEntity) => {
    if (entity instanceof Annotation) {
        return postInstantiateForClassifier(entity, extendingSettingsFor(entity).join(""))
    }

    if (entity instanceof Concept) {
        const settings = [
            cond(entity.abstract, `.IsAbstract()`),
            cond(entity.partition, `.IsPartition()`),
            ...extendingSettingsFor(entity)
        ]
        return postInstantiateForClassifier(entity, settings.join(""))
    }

    if (entity instanceof Enumeration) {
        return entity.literals.length > 0
            ? [``, entity.literals.map((literal) => `${entity.name}.${constructorCall(literal)};`)]
            : []
    }

    if (entity instanceof Interface) {
        const extendingExpr = entity.extends.length > 0
            ? `.Extending(${entity.extends.map(typeRefFor).join(", ")})`
            : ``
        return postInstantiateForClassifier(entity, extendingExpr)
    }

    if (entity instanceof PrimitiveType) {
        return []   // (nothing to be done)
    }

    return `// instance of ${entity.constructor.name} not handled by #postInstantiate`
}


const featureUsesBuiltIns = (feature: Feature) => {
    if (feature instanceof Property) {
        return feature.type?.language === lioncoreBuiltins
    }
    if (feature instanceof Link) {
        return feature.type?.language === lioncoreBuiltins
    }
    return false
}

const classifierUsesBuiltIns = (classifier: Classifier) =>
       classifier.features.some(featureUsesBuiltIns)
    // TODO  also check .extends and .implementing


export const languageInstantiationFor = (language: Language, className: string, namespace: string) =>
    asString([
`// Generated by C# language instantiator generator!
// Don't modify, but you can delete and regenerate any time!

namespace ${namespace};

`,
        // only emit the "M2-using" statement when BuiltIns is actually referenced:
        cond(
            language.entities.some((entity) => entity instanceof Classifier && classifierUsesBuiltIns(entity)),
            `using LionWeb.Core.M2;`
        ),
`using LionWeb.Core.M3;

public static class ${className}
{
    public static readonly Language Instance = new(
        "${language.id}",
        "${language.key}",
        "${language.name}",
        "${language.version}"
    );

    static ${className}()
    {`,
        indent(2)([
            nameSorted(language.entities).map(
                (entity: LanguageEntity) =>
                    `var ${entity.name} = Instance.${constructorCall(entity)};`
            ),
            nameSorted(language.entities).map(postInstantiate)
        ]),
`    }
}`
    ])


// TODO  this generator only works for ONE language that has no references to other languages other than LionCore-builtins

